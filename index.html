<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comic Viewer Final</title>
  <style>
    :root {
      --blur-amount: 20px;
      --brightness: 0.8;
      --bg-opacity: 0.8;
      --bg-zoom: 120%;
      --bg-offset: -10%;
      --column-count: 4;
      --column-gap: 20px;
      --item-margin: 20px;
      --border-width: 6px;
      --padding: 20px;
      --transition-duration: 1.0s;
      --greyscale-amount: 0.8;
    }
    
    body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      overflow-y: hidden;
      background-color: #fff;
      font-family: Arial, sans-serif;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1000;
    }
    #overlay svg {
      width: 15vw;
      height: auto;
    }
    #background {
      position: fixed;
      top: var(--bg-offset);
      left: var(--bg-offset);
      width: var(--bg-zoom);
      height: var(--bg-zoom);
      background-size: var(--bg-zoom);
      background-position: center center;
      filter: blur(var(--blur-amount)) brightness(var(--brightness));
      opacity: var(--bg-opacity);
      transition: background-image 1s ease-in-out;
      z-index: -1;
    }
    #canvas {
      padding: var(--padding);
      position: absolute;
      top: 0; left: 0;
      transition: transform var(--transition-duration) ease-in-out;
      transform-origin: top left;
      width: calc(100% - calc(var(--padding) * 2));
    }
    .masonry-container {
      column-count: var(--column-count);
      column-gap: var(--column-gap);
      width: 100%;
    }
    .comic-item {
      display: inline-block;
      width: 100%;
      margin-bottom: var(--item-margin);
      break-inside: avoid;
      border: none;
      padding: 0;
    }
    .comic-img {
      width: 100%;
      height: auto;
      display: block;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      transition: filter var(--transition-duration) ease-in-out,
                  box-shadow var(--transition-duration) ease-in-out;
      line-height: 0;
      margin: 0;
      padding: 0;
    }
    .comic-img.inactive {
      filter: grayscale(var(--greyscale-amount));
    }
    .cover-image {
      width: 100%;
      height: auto;
      display: block;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      transition: filter var(--transition-duration) ease-in-out;
      line-height: 0;
      margin: 0;
      padding: 0;
    }
    .cover-image.inactive {
      filter: grayscale(var(--greyscale-amount));
    }
    
    .cover-item {
      display: block;
      width: 100%;
      margin-bottom: var(--item-margin);
      break-inside: avoid;
      border: none;
      padding: 0;
    }
    /* Make sure cover spans all columns */
    .cover-item {
      column-span: all;
    }
    
    /* Narration box base styling */
    .narration-box {
      background-color: white;
      padding: 8px 12px;
      font-family: "Comic Sans MS", "Comic Sans", cursive;
      font-size: 16px;
      position: absolute;
      z-index: 10;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      max-width: 80%; /* Allow more width */
      word-wrap: break-word; /* Enable word wrapping */
      overflow-wrap: break-word; /* Modern browsers */
      hyphens: auto; /* Allow hyphenation */
      white-space: normal; /* Ensure text wraps */
      line-height: 1.3; /* Better line spacing for readability */
      font-style: italic; /* Make text italic */
    }
    
    /* Position-specific styles */
    .narration-box-top-left {
      text-align: left;
    }
    
    .narration-box-top-right {
      text-align: right;
    }
    
    .narration-box-bottom-left {
      text-align: left;
    }
    
    .narration-box-bottom-right {
      text-align: right;
    }
    
    /* Image container for positioning narration */
    .img-container {
      position: relative;
      width: 100%;
      height: auto;
      display: block;
      line-height: 0;
      padding: 0;
      margin: 0;
    }
    
    /* Ensure images have the border styling we need */
    .comic-img, .cover-image {
      display: block;
      width: 100%;
      height: auto;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      line-height: 0;
      position: relative;
    }
  </style>
</head>
<body>

<div id="overlay">
  <svg viewBox="0 0 100 100"><polygon points="30,20 30,80 80,50" fill="#000"/></svg>
</div>

<div id="background"></div>
<div id="canvas">
  <div class="masonry-container" id="masonry"></div>
</div>

<script>
// Application configuration
const config = {
  // Background effect settings
  background: {
    blurAmount: 40, // px
    brightness: 0.8, // 0 to 1
    opacity: 0.8, // 0 to 1
    zoom: 120, // percentage
    offset: -10 // percentage
  },
  
  // Image transition settings
  transition: {
    duration: 1.0, // seconds
    initialDelay: 0, // ms delay before starting animation
    timeBetweenSlides: 4000, // ms between slides
    greyOutDelay: 500 // ms to wait after greying out before moving to next slide
  },
  
  // Layout settings
  layout: {
    columnCount: 3,
    columnGap: 20, // px
    itemMargin: 20, // px
    borderWidth: 6, // px
    padding: 20 // px
  },
  
  // Image effect settings
  effects: {
    greyscaleAmount: 0.75 // 0 to 1 (0 = no greyscale, 1 = full greyscale)
  },
  
  // Image paths
  images: [
    { path: "1_0.png", isCover: true,  chapter: 1, narration: { line: "The adventure begins...", position: "bottom-right" } },
    { path: "1_1.png", isCover: false, chapter: 1, narration: { line: "Meanwhile, at the bookstore...", position: "top-left" } },
    { path: "1_2.png", isCover: false, chapter: 1 },
    { path: "1_3.png", isCover: false, chapter: 1, narration: { line: "Suddenly!", position: "top-right" } },
    { path: "1_4.png", isCover: false, chapter: 1 },
    { path: "1_5.png", isCover: false, chapter: 1, narration: { line: "The revelation...", position: "bottom-left" } },
    { path: "1_6.png", isCover: false, chapter: 1 },
    { path: "1_7.png", isCover: false, chapter: 1 },
    { path: "1_8.png", isCover: false, chapter: 1 },
    { path: "1_9.png", isCover: false, chapter: 1 },
    { path: "2_0.png", isCover: true,  chapter: 2, narration: { line: "Chapter 2: The New Beginning", position: "bottom-right" } },
    { path: "2_1.png", isCover: false, chapter: 2 },
    { path: "2_2.png", isCover: false, chapter: 2 },
    { path: "2_3.png", isCover: false, chapter: 2 },
    { path: "2_4.png", isCover: false, chapter: 2 },
    { path: "2_5.png", isCover: false, chapter: 2 },
    { path: "2_6.png", isCover: false, chapter: 2 },
    { path: "2_7.png", isCover: false, chapter: 2 },
    { path: "2_8.png", isCover: false, chapter: 2 },
    { path: "2_9.png", isCover: false, chapter: 2 },
    // Chapter 3
    { path: "3_0.png", isCover: true,  chapter: 3 },
    { path: "3_1.png", isCover: false, chapter: 3 },
    { path: "3_2.png", isCover: false, chapter: 3 },
    { path: "3_3.png", isCover: false, chapter: 3 },
    { path: "3_4.png", isCover: false, chapter: 3 },
    { path: "3_5.png", isCover: false, chapter: 3 },
    { path: "3_6.png", isCover: false, chapter: 3 },
    { path: "3_7.png", isCover: false, chapter: 3 },
    { path: "3_8.png", isCover: false, chapter: 3 },
    { path: "3_9.png", isCover: false, chapter: 3 },
    // Chapter 4
    { path: "4_0.png", isCover: true,  chapter: 4 },
    { path: "4_1.png", isCover: false, chapter: 4 },
    { path: "4_2.png", isCover: false, chapter: 4 },
    { path: "4_3.png", isCover: false, chapter: 4 },
    { path: "4_4.png", isCover: false, chapter: 4 },
    { path: "4_5.png", isCover: false, chapter: 4 },
    { path: "4_6.png", isCover: false, chapter: 4 },
    { path: "4_7.png", isCover: false, chapter: 4 },
    { path: "4_8.png", isCover: false, chapter: 4 },
    { path: "4_9.png", isCover: false, chapter: 4 },
    // Chapter 5
    { path: "5_0.png", isCover: true,  chapter: 5 },
    { path: "5_1.png", isCover: false, chapter: 5 },
    { path: "5_2.png", isCover: false, chapter: 5 },
    { path: "5_3.png", isCover: false, chapter: 5 },
    { path: "5_4.png", isCover: false, chapter: 5 },
    { path: "5_5.png", isCover: false, chapter: 5 },
    { path: "5_6.png", isCover: false, chapter: 5 },
    { path: "5_7.png", isCover: false, chapter: 5 },
    { path: "5_8.png", isCover: false, chapter: 5 },
    { path: "5_9.png", isCover: false, chapter: 5 },
    // Chapter 6
    { path: "6_0.png", isCover: true,  chapter: 6 }
  ]
};

const canvas = document.getElementById('canvas');
const masonry = document.getElementById('masonry');
const background = document.getElementById('background');
let positions = [];
let allImages = [];

// Add a helper function for image paths
function getImagePath(imagePath) {
  return `images/${imagePath}`;
}

// Apply initial configuration
function applyConfig() {
  // Apply background settings
  document.documentElement.style.setProperty('--blur-amount', `${config.background.blurAmount}px`);
  document.documentElement.style.setProperty('--brightness', config.background.brightness);
  document.documentElement.style.setProperty('--bg-opacity', config.background.opacity);
  document.documentElement.style.setProperty('--bg-zoom', `${config.background.zoom}%`);
  document.documentElement.style.setProperty('--bg-offset', `${config.background.offset}%`);
  
  // Apply layout settings
  document.documentElement.style.setProperty('--column-count', config.layout.columnCount);
  document.documentElement.style.setProperty('--column-gap', `${config.layout.columnGap}px`);
  document.documentElement.style.setProperty('--item-margin', `${config.layout.itemMargin}px`);
  document.documentElement.style.setProperty('--border-width', `${config.layout.borderWidth}px`);
  document.documentElement.style.setProperty('--padding', `${config.layout.padding}px`);
  
  // Apply transition settings
  document.documentElement.style.setProperty('--transition-duration', `${config.transition.duration}s`);
  
  // Apply effect settings
  document.documentElement.style.setProperty('--greyscale-amount', config.effects.greyscaleAmount);
}

function createNarrationBox(narration) {
  const box = document.createElement('div');
  box.className = `narration-box narration-box-${narration.position}`;
  box.textContent = narration.line;
  
  // Calculate optimal width based on text length
  // Use a more accurate width estimation: ~8px per character for Comic Sans
  // Add extra for padding and adjust based on text length patterns
  const textLength = narration.line.length;
  let estimatedWidth;
  
  if (textLength < 10) {
    // Very short text
    estimatedWidth = textLength * 12 + 30; // More space per character for short phrases
  } else if (textLength < 20) {
    // Short to medium text
    estimatedWidth = textLength * 10 + 40;
  } else if (textLength < 40) {
    // Medium text
    estimatedWidth = textLength * 8 + 60;
  } else {
    // Long text - cap at a reasonable max width and let it wrap
    estimatedWidth = Math.min(textLength * 7 + 80, 350);
  }
  
  box.style.width = `${estimatedWidth}px`;
  
  // Apply direct positioning for more reliability
  if (narration.position === 'top-left') {
    box.style.top = '0';
    box.style.left = '0';
  } else if (narration.position === 'top-right') {
    box.style.top = '0';
    box.style.right = '0';
  } else if (narration.position === 'bottom-left') {
    box.style.bottom = '0';
    box.style.left = '0';
  } else if (narration.position === 'bottom-right') {
    box.style.bottom = '0';
    box.style.right = '0';
  }
  
  return box;
}

function setupImages(callback) {
  let loaded = 0;
  
  // Set initial background to first image
  if (config.images.length > 0) {
    background.style.backgroundImage = `url(${getImagePath(config.images[0].path)})`;
    updateBackgroundFilter();
  }
  
  config.images.forEach((imgObj, index) => {
    const item = document.createElement('div');
    
    // Add data attribute for chapter
    item.dataset.chapter = imgObj.chapter;
    
    // Create container for relative positioning
    const container = document.createElement('div');
    container.className = 'img-container';
    
    // Check if this is a cover image
    if (imgObj.isCover) {
      item.className = 'cover-item';
      const img = new Image();
      img.src = getImagePath(imgObj.path);
      img.className = "cover-image";
      // Let CSS handle border styling
      allImages.push(img);
      
      img.onload = () => {
        loaded++;
        if (loaded === config.images.length) {
          setTimeout(() => { calculatePositions(); if (callback) callback(); }, 100);
        }
      };
      img.onerror = () => console.error("Failed to load image:", imgObj.path);
      
      container.appendChild(img);
      
      // Add narration if specified
      if (imgObj.narration && imgObj.narration.line) {
        const narrationBox = createNarrationBox(imgObj.narration);
        container.appendChild(narrationBox);
      }
      
      item.appendChild(container);
      masonry.appendChild(item);
    } else {
      // Regular comic items
      item.className = 'comic-item';
      const img = new Image();
      img.src = getImagePath(imgObj.path);
      img.className = "comic-img";
      // Let CSS handle border styling
      allImages.push(img);
      
      img.onload = () => {
        loaded++;
        if (loaded === config.images.length) {
          setTimeout(() => { calculatePositions(); if (callback) callback(); }, 100);
        }
      };
      img.onerror = () => console.error("Failed to load image:", imgObj.path);
      
      container.appendChild(img);
      
      // Add narration if specified
      if (imgObj.narration && imgObj.narration.line) {
        const narrationBox = createNarrationBox(imgObj.narration);
        container.appendChild(narrationBox);
      }
      
      item.appendChild(container);
      masonry.appendChild(item);
    }
  });
}

function updateBackgroundFilter() {
  background.style.filter = `blur(var(--blur-amount)) brightness(var(--brightness))`;
  background.style.opacity = getComputedStyle(document.documentElement).getPropertyValue('--bg-opacity');
}

function calculatePositions() {
  positions = [];
  // Include both cover-item and comic-item elements
  document.querySelectorAll('.comic-item, .cover-item').forEach(item => {
    const rect = item.getBoundingClientRect();
    positions.push({
      x: item.offsetLeft - config.layout.padding,
      y: item.offsetTop - config.layout.padding,
      w: rect.width + (config.layout.padding * 2),
      h: rect.height + (config.layout.padding * 2)
    });
  });
}

function startComicAnimation() {
  let idx = 0;
  let prevIdx = -1;
  
  function moveToImage() {
    if (idx >= positions.length) return;
    
    function zoomToCurrentImage() {
      const p = positions[idx];
  
      // Update background image to match current foreground image
      const currentImg = allImages[idx];
      if (currentImg) {
        // Extract the original path from the image object
        const originalPath = config.images[idx].path;
        background.style.backgroundImage = `url(${getImagePath(originalPath)})`;
        updateBackgroundFilter();
      }
  
      const scaleX = window.innerWidth / p.w;
      const scaleY = window.innerHeight / p.h;
      const scale = Math.min(scaleX, scaleY);
  
      const translateX = -(p.x - (window.innerWidth / scale - p.w) / 2);
      const translateY = -(p.y - (window.innerHeight / scale - p.h) / 2);
  
      canvas.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
  
      prevIdx = idx;
      idx++;
      
      // For cover images, use a different timing before moving to the next image
      if (config.images[prevIdx].isCover) {
        setTimeout(moveToImage, config.transition.timeBetweenSlides * 1.5); // Longer time on cover
      } else {
        setTimeout(moveToImage, config.transition.timeBetweenSlides);
      }
    }
    
    // Make all images inactive (greyscale) except the current one
    allImages.forEach((img, i) => {
      if (i === idx) {
        img.classList.remove('inactive');
      } else {
        img.classList.add('inactive');
      }
    });
    
    // Wait for greyscale transition to complete before zooming
    setTimeout(zoomToCurrentImage, config.transition.greyOutDelay);
  }
  
  moveToImage();
}

document.getElementById('overlay').onclick = () => {
  document.getElementById('overlay').style.display = 'none';
  
  // Request fullscreen mode
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) { /* Safari */
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) { /* IE11 */
    document.documentElement.msRequestFullscreen();
  }
  
  // Add delay before starting the animation
  setTimeout(() => {
    // Set initial background to first image
    if (allImages.length > 0 && config.images.length > 0) {
      background.style.backgroundImage = `url(${getImagePath(config.images[0].path)})`;
      updateBackgroundFilter();
    }
    
    // Grey out all images
    allImages.forEach(img => {
      img.classList.add('inactive');
    });
    
    // Wait for greying effect to be visible, then start animation
    setTimeout(() => {
      startComicAnimation();
    }, config.transition.greyOutDelay);
  }, config.transition.initialDelay);
};

// Add handler for exiting fullscreen
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);

function handleFullscreenChange() {
  if (!document.fullscreenElement && 
      !document.webkitFullscreenElement && 
      !document.mozFullScreenElement && 
      !document.msFullscreenElement) {
    // Reset the animation if user exits fullscreen
    // (Uncomment if you want to restart the animation when exiting fullscreen)
    // location.reload();
  }
}

window.onresize = calculatePositions;

// Initialize the application
applyConfig();
setupImages();
</script>

</body>
</html>