<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PanelPop</title>
  <style>
    :root {
      --blur-amount: 20px;
      --brightness: 0.8;
      --bg-opacity: 0.8;
      --bg-zoom: 120%;
      --bg-offset: -10%;
      --column-count: 4;
      --column-gap: 20px;
      --item-margin: 20px;
      --border-width: 6px;
      --padding: 20px;
      --transition-duration: 1.0s;
      --greyscale-amount: 0.8;
    }
    
    body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
      overflow-y: hidden;
      background-color: #fff;
      font-family: Arial, sans-serif;
    }
    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 1000;
    }
    #overlay svg {
      width: 15vw;
      height: auto;
    }
    #background {
      position: fixed;
      top: var(--bg-offset);
      left: var(--bg-offset);
      width: var(--bg-zoom);
      height: var(--bg-zoom);
      background-size: var(--bg-zoom);
      background-position: center center;
      filter: blur(var(--blur-amount)) brightness(var(--brightness));
      opacity: var(--bg-opacity);
      transition: background-image 1s ease-in-out;
      z-index: -1;
    }
    #canvas {
      padding: var(--padding);
      position: absolute;
      top: 0; left: 0;
      transition: transform var(--transition-duration) ease-in-out;
      transform-origin: top left;
      width: calc(100% - calc(var(--padding) * 2));
    }
    .masonry-container {
      column-count: var(--column-count);
      column-gap: var(--column-gap);
      width: 100%;
    }
    .comic-item {
      display: inline-block;
      width: 100%;
      margin-bottom: var(--item-margin);
      break-inside: avoid;
      border: none;
      padding: 0;
    }
    .comic-img {
      width: 100%;
      height: auto;
      display: block;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      transition: filter var(--transition-duration) ease-in-out,
                  box-shadow var(--transition-duration) ease-in-out;
      line-height: 0;
      margin: 0;
      padding: 0;
    }
    .comic-img.inactive {
      filter: grayscale(var(--greyscale-amount));
    }
    .cover-image {
      width: 100%;
      height: auto;
      display: block;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      transition: filter var(--transition-duration) ease-in-out;
      line-height: 0;
      margin: 0;
      padding: 0;
    }
    .cover-image.inactive {
      filter: grayscale(var(--greyscale-amount));
    }
    
    .cover-item {
      display: block;
      width: 100%;
      margin-bottom: var(--item-margin);
      break-inside: avoid;
      border: none;
      padding: 0;
    }
    /* Make sure cover spans all columns */
    .cover-item {
      column-span: all;
    }
    
    /* Narration box base styling */
    .narration-box {
      background-color: white;
      padding: 8px 12px;
      font-family: "Comic Sans MS", "Comic Sans", cursive;
      font-size: 16px;
      position: absolute;
      z-index: 10;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      max-width: 80%; /* Allow more width */
      word-wrap: break-word; /* Enable word wrapping */
      overflow-wrap: break-word; /* Modern browsers */
      hyphens: auto; /* Allow hyphenation */
      white-space: normal; /* Ensure text wraps */
      line-height: 1.3; /* Better line spacing for readability */
      font-style: italic; /* Make text italic */
    }
    
    /* Position-specific styles */
    .narration-box-top-left {
      text-align: left;
    }
    
    .narration-box-top-right {
      text-align: right;
    }
    
    .narration-box-bottom-left {
      text-align: left;
    }
    
    .narration-box-bottom-right {
      text-align: right;
    }
    
    /* Image container for positioning narration */
    .img-container {
      position: relative;
      width: 100%;
      height: auto;
      display: block;
      line-height: 0;
      padding: 0;
      margin: 0;
    }
    
    /* Ensure images have the border styling we need */
    .comic-img, .cover-image {
      display: block;
      width: 100%;
      height: auto;
      border: var(--border-width) solid black;
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      line-height: 0;
      position: relative;
    }
  </style>
</head>
<body>

<div id="overlay">
  <svg viewBox="0 0 100 100"><polygon points="30,20 30,80 80,50" fill="#000"/></svg>
</div>

<div id="background"></div>
<div id="canvas">
  <div class="masonry-container" id="masonry"></div>
</div>

<script>
// Application configuration
const config = {
  // Background effect settings
  background: {
    blurAmount: 40, // px
    brightness: 0.8, // 0 to 1
    opacity: 0.8, // 0 to 1
    zoom: 120, // percentage
    offset: -10 // percentage
  },
  
  // Image transition settings
  transition: {
    transitionEffectDuration: 1.0, // Time in seconds it takes for visual effects (like greyscale) to complete their transition
    initialDelay: 5000, // ms delay before starting animation
    timeBetweenSlides: 3500, // ms between slides
    greyOutDelay: 500, // ms to wait after greying out before moving to next slide
    startingFrameIndex: 0 // The frame index to start from (0 = first image in the array)
  },
  
  // Layout settings
  layout: {
    columnCount: 3,
    columnGap: 20, // px
    itemMargin: 20, // px
    borderWidth: 6, // px
    padding: 20 // px
  },
  
  // Image effect settings
  effects: {
    greyscaleAmount: 0.75 // 0 to 1 (0 = no greyscale, 1 = full greyscale)
  },
  
  // Image paths
  images: [
    { path: "1_0.png", isCover: true,  chapter: 1 },
    { path: "1_1.png", isCover: false, chapter: 1, narration: { line: "Darkness", position: "top-left" } },
    { path: "1_2.png", isCover: false, chapter: 1 },
    { path: "1_3.png", isCover: false, chapter: 1 },
    { path: "1_4.png", isCover: false, chapter: 1, narration: { line: "Something's off", position: "top-right" } },
    { path: "1_5.png", isCover: false, chapter: 1, narration: { line: "Bzzzt, scanning", position: "bottom-right" } },
    { path: "1_6.png", isCover: false, chapter: 1, narration: { line: "We march!", position: "bottom-left" } },
    { path: "1_7.png", isCover: false, chapter: 1 },
    { path: "1_8.png", isCover: false, chapter: 1 },
    { path: "1_9.png", isCover: false, chapter: 1, narration: { line: "The city...", position: "bottom-left" } },
    // Chapter 2
    { path: "2_0.png", isCover: true,  chapter: 2 },
    { path: "2_1.png", isCover: false, chapter: 2 },
    { path: "2_2.png", isCover: false, chapter: 2, narration: { line: "Investigating", position: "bottom-left" } },
    { path: "2_3.png", isCover: false, chapter: 2 },
    { path: "2_4.png", isCover: false, chapter: 2, narration: { line: "An ambush", position: "bottom-right" } },
    { path: "2_5.png", isCover: false, chapter: 2, narration: { line: "ATTACK!", position: "bottom-left" } },
    { path: "2_6.png", isCover: false, chapter: 2 },
    { path: "2_7.png", isCover: false, chapter: 2 },
    { path: "2_8.png", isCover: false, chapter: 2, narration: { line: "Sniff, sniff", position: "top-right" } },
    { path: "2_9.png", isCover: false, chapter: 2, narration: { line: "INTRUDER FOUND!", position: "bottom-left" } },
    // Chapter 3
    { path: "3_0.png", isCover: true,  chapter: 3 },
    { path: "3_1.png", isCover: false, chapter: 3 },
    { path: "3_2.png", isCover: false, chapter: 3 },
    { path: "3_3.png", isCover: false, chapter: 3, narration: { line: "Finally inside...", position: "bottom-right" } },
    { path: "3_4.png", isCover: false, chapter: 3, narration: { line: "It's a trap!", position: "bottom-left" } },
    { path: "3_5.png", isCover: false, chapter: 3, narration: { line: "FIGHT!", position: "top-right" } },
    { path: "3_6.png", isCover: false, chapter: 3, narration: { line: "NOOO!", position: "bottom-right" } },
    { path: "3_7.png", isCover: false, chapter: 3 },
    { path: "3_8.png", isCover: false, chapter: 3 },
    { path: "3_9.png", isCover: false, chapter: 3 },
    // Chapter 4
    { path: "4_0.png", isCover: true,  chapter: 4 },
    { path: "4_1.png", isCover: false, chapter: 4 },
    { path: "4_2.png", isCover: false, chapter: 4 },
    { path: "4_3.png", isCover: false, chapter: 4 },
    { path: "4_4.png", isCover: false, chapter: 4 },
    { path: "4_5.png", isCover: false, chapter: 4 },
    { path: "4_6.png", isCover: false, chapter: 4 },
    { path: "4_7.png", isCover: false, chapter: 4 },
    { path: "4_8.png", isCover: false, chapter: 4 },
    { path: "4_9.png", isCover: false, chapter: 4 },
    // Chapter 5
    { path: "5_0.png", isCover: true,  chapter: 5 },
    { path: "5_1.png", isCover: false, chapter: 5 },
    { path: "5_2.png", isCover: false, chapter: 5 },
    { path: "5_3.png", isCover: false, chapter: 5 },
    { path: "5_4.png", isCover: false, chapter: 5 },
    { path: "5_5.png", isCover: false, chapter: 5 },
    { path: "5_6.png", isCover: false, chapter: 5 },
    { path: "5_7.png", isCover: false, chapter: 5 },
    { path: "5_8.png", isCover: false, chapter: 5 },
    { path: "5_9.png", isCover: false, chapter: 5 },
    // Chapter 6
    { path: "6_0.png", isCover: true,  chapter: 6 }
  ]
};

const canvas = document.getElementById('canvas');
const masonry = document.getElementById('masonry');
const background = document.getElementById('background');
let positions = [];
let allImages = [];

// Global state variables for animation control
let isPaused = false;
let currentTimeout = null;
let currentFrameIndex = -1; // Start at -1 to indicate no frame is currently shown

// Add a helper function for image paths
function getImagePath(imagePath) {
  return `images/${imagePath}`;
}

// Apply initial configuration
function applyConfig() {
  // Apply background settings
  document.documentElement.style.setProperty('--blur-amount', `${config.background.blurAmount}px`);
  document.documentElement.style.setProperty('--brightness', config.background.brightness);
  document.documentElement.style.setProperty('--bg-opacity', config.background.opacity);
  document.documentElement.style.setProperty('--bg-zoom', `${config.background.zoom}%`);
  document.documentElement.style.setProperty('--bg-offset', `${config.background.offset}%`);
  
  // Apply layout settings
  document.documentElement.style.setProperty('--column-count', config.layout.columnCount);
  document.documentElement.style.setProperty('--column-gap', `${config.layout.columnGap}px`);
  document.documentElement.style.setProperty('--item-margin', `${config.layout.itemMargin}px`);
  document.documentElement.style.setProperty('--border-width', `${config.layout.borderWidth}px`);
  document.documentElement.style.setProperty('--padding', `${config.layout.padding}px`);
  
  // Apply transition settings - controls how long visual transitions like greyscale fade take to complete
  document.documentElement.style.setProperty('--transition-duration', `${config.transition.transitionEffectDuration}s`);
  
  // Apply effect settings
  document.documentElement.style.setProperty('--greyscale-amount', config.effects.greyscaleAmount);
}

function createNarrationBox(narration) {
  const box = document.createElement('div');
  box.className = `narration-box narration-box-${narration.position}`;
  box.textContent = narration.line;
  
  // Calculate optimal width based on text length
  // Use a more accurate width estimation: ~8px per character for Comic Sans
  // Add extra for padding and adjust based on text length patterns
  const textLength = narration.line.length;
  let estimatedWidth;
  
  if (textLength < 10) {
    // Very short text
    estimatedWidth = textLength * 12 + 30; // More space per character for short phrases
  } else if (textLength < 20) {
    // Short to medium text
    estimatedWidth = textLength * 10 + 40;
  } else if (textLength < 40) {
    // Medium text
    estimatedWidth = textLength * 8 + 60;
  } else {
    // Long text - cap at a reasonable max width and let it wrap
    estimatedWidth = Math.min(textLength * 7 + 80, 350);
  }
  
  box.style.width = `${estimatedWidth}px`;
  
  // Apply direct positioning for more reliability
  if (narration.position === 'top-left') {
    box.style.top = '0';
    box.style.left = '0';
  } else if (narration.position === 'top-right') {
    box.style.top = '0';
    box.style.right = '0';
  } else if (narration.position === 'bottom-left') {
    box.style.bottom = '0';
    box.style.left = '0';
  } else if (narration.position === 'bottom-right') {
    box.style.bottom = '0';
    box.style.right = '0';
  }
  
  return box;
}

function setupImages(callback) {
  let loaded = 0;
  
  // Set initial background to first image
  if (config.images.length > 0) {
    background.style.backgroundImage = `url(${getImagePath(config.images[0].path)})`;
    updateBackgroundFilter();
  }
  
  config.images.forEach((imgObj, index) => {
    const item = document.createElement('div');
    
    // Add data attribute for chapter
    item.dataset.chapter = imgObj.chapter;
    
    // Create container for relative positioning
    const container = document.createElement('div');
    container.className = 'img-container';
    
    // Check if this is a cover image
    if (imgObj.isCover) {
      item.className = 'cover-item';
      const img = new Image();
      img.src = getImagePath(imgObj.path);
      img.className = "cover-image";
      // Let CSS handle border styling
      allImages.push(img);
      
      img.onload = () => {
        loaded++;
        if (loaded === config.images.length) {
          setTimeout(() => { calculatePositions(); if (callback) callback(); }, 100);
        }
      };
      img.onerror = () => console.error("Failed to load image:", imgObj.path);
      
      container.appendChild(img);
      
      // Add narration if specified
      if (imgObj.narration && imgObj.narration.line) {
        const narrationBox = createNarrationBox(imgObj.narration);
        container.appendChild(narrationBox);
      }
      
      item.appendChild(container);
      masonry.appendChild(item);
    } else {
      // Regular comic items
      item.className = 'comic-item';
      const img = new Image();
      img.src = getImagePath(imgObj.path);
      img.className = "comic-img";
      // Let CSS handle border styling
      allImages.push(img);
      
      img.onload = () => {
        loaded++;
        if (loaded === config.images.length) {
          setTimeout(() => { calculatePositions(); if (callback) callback(); }, 100);
        }
      };
      img.onerror = () => console.error("Failed to load image:", imgObj.path);
      
      container.appendChild(img);
      
      // Add narration if specified
      if (imgObj.narration && imgObj.narration.line) {
        const narrationBox = createNarrationBox(imgObj.narration);
        container.appendChild(narrationBox);
      }
      
      item.appendChild(container);
      masonry.appendChild(item);
    }
  });
}

function updateBackgroundFilter() {
  background.style.filter = `blur(var(--blur-amount)) brightness(var(--brightness))`;
  background.style.opacity = getComputedStyle(document.documentElement).getPropertyValue('--bg-opacity');
}

function calculatePositions() {
  positions = [];
  // Include both cover-item and comic-item elements
  document.querySelectorAll('.comic-item, .cover-item').forEach(item => {
    const rect = item.getBoundingClientRect();
    positions.push({
      x: item.offsetLeft - config.layout.padding,
      y: item.offsetTop - config.layout.padding,
      w: rect.width + (config.layout.padding * 2),
      h: rect.height + (config.layout.padding * 2)
    });
  });
}

function startComicAnimation() {
  // Start the animation with the frame specified in config, subtracting 1 to fix offset
  const startFrame = config.transition.startingFrameIndex - 1;
  isPaused = false;
  moveToImage(startFrame, false);
}

// Function to handle frame navigation and animation
function moveToImage(targetIndex, manual = false) {
  // Save the previous index before updating
  const previousIndex = currentFrameIndex;
  
  // Update to the target index
  currentFrameIndex = targetIndex;
  
  // Validate bounds
  if (currentFrameIndex < 0) currentFrameIndex = 0;
  if (currentFrameIndex >= positions.length) currentFrameIndex = positions.length - 1;
  
  function zoomToCurrentImage() {
    const p = positions[currentFrameIndex];

    // Update background image to match current foreground image
    const currentImg = allImages[currentFrameIndex];
    if (currentImg) {
      // Extract the original path from the image object
      const originalPath = config.images[currentFrameIndex].path;
      background.style.backgroundImage = `url(${getImagePath(originalPath)})`;
      updateBackgroundFilter();
    }

    const scaleX = window.innerWidth / p.w;
    const scaleY = window.innerHeight / p.h;
    const scale = Math.min(scaleX, scaleY);

    const translateX = -(p.x - (window.innerWidth / scale - p.w) / 2);
    const translateY = -(p.y - (window.innerHeight / scale - p.h) / 2);

    canvas.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;

    // If this is automatic navigation, schedule the next frame
    if (!manual && !isPaused) {
      const nextIndex = currentFrameIndex + 1;
      if (nextIndex < positions.length) {
        currentTimeout = setTimeout(() => {
          moveToImage(nextIndex, false);
        }, config.transition.timeBetweenSlides);
      }
    }
  }
  
  // Update image visibility - make all inactive except current
  allImages.forEach((img, i) => {
    if (i === currentFrameIndex) {
      img.classList.remove('inactive');
    } else {
      img.classList.add('inactive');
    }
  });
  
  // If manual navigation, zoom immediately; otherwise, wait for greyscale transition
  if (manual) {
    zoomToCurrentImage();
  } else {
    currentTimeout = setTimeout(zoomToCurrentImage, config.transition.greyOutDelay);
  }
}

// Function to manually go to previous frame
function goToPreviousFrame() {
  // Clear any pending timeouts
  if (currentTimeout) {
    clearTimeout(currentTimeout);
    currentTimeout = null;
  }
  
  // Pause the animation when using manual controls
  isPaused = true;
  
  // Move to previous frame (if possible)
  const prevIndex = Math.max(0, currentFrameIndex - 1);
  moveToImage(prevIndex, true);
}

// Function to manually go to next frame
function goToNextFrame() {
  // Clear any pending timeouts
  if (currentTimeout) {
    clearTimeout(currentTimeout);
    currentTimeout = null;
  }
  
  // Pause the animation when using manual controls
  isPaused = true;
  
  // Move to next frame (if possible)
  const nextIndex = Math.min(positions.length - 1, currentFrameIndex + 1);
  moveToImage(nextIndex, true);
}

// Function to toggle pause/resume
function togglePause() {
  isPaused = !isPaused;
  
  if (isPaused) {
    // If paused, clear any pending timeouts
    if (currentTimeout) {
      clearTimeout(currentTimeout);
      currentTimeout = null;
    }
  } else {
    // If resumed, continue animation from current frame to next frame
    const nextIndex = currentFrameIndex + 1;
    if (nextIndex < positions.length) {
      moveToImage(nextIndex, false);
    }
  }
}

// Handle keyboard controls
function handleKeyboardControls(event) {
  if (event.key === ' ') { // Spacebar
    // If overlay is still visible, start the animation (same as clicking)
    if (document.getElementById('overlay').style.display !== 'none') {
      startAnimation();
    } else {
      // Otherwise toggle pause/resume
      togglePause();
    }
    event.preventDefault();
    return;
  }
  
  // Only process arrow keys if animation has started
  if (document.getElementById('overlay').style.display !== 'none') {
    return;
  }
  
  switch (event.key) {
    case 'ArrowLeft':
      goToPreviousFrame();
      event.preventDefault();
      break;
    case 'ArrowRight':
      goToNextFrame();
      event.preventDefault();
      break;
  }
}

// Extract the animation start logic into a separate function
function startAnimation() {
  document.getElementById('overlay').style.display = 'none';
  
  // Request fullscreen mode
  if (document.documentElement.requestFullscreen) {
    document.documentElement.requestFullscreen();
  } else if (document.documentElement.webkitRequestFullscreen) { /* Safari */
    document.documentElement.webkitRequestFullscreen();
  } else if (document.documentElement.msRequestFullscreen) { /* IE11 */
    document.documentElement.msRequestFullscreen();
  }
  
  // Add delay before starting the animation
  setTimeout(() => {
    // Grey out all images initially
    allImages.forEach(img => {
      img.classList.add('inactive');
    });
    
    // Reset animation control variables
    isPaused = false;
    if (currentTimeout) {
      clearTimeout(currentTimeout);
    }
    
    // Get the start frame index from config, subtracting 1 to fix offset
    const startFrame = config.transition.startingFrameIndex - 1;
    
    // Set initial background to starting frame
    if (allImages.length > 0 && config.images.length > 0) {
      // Ensure we don't exceed bounds
      const validStartFrame = Math.max(0, Math.min(startFrame, config.images.length - 1));
      background.style.backgroundImage = `url(${getImagePath(config.images[validStartFrame].path)})`;
      updateBackgroundFilter();
    }
    
    // Wait for greying effect to be visible, then start animation
    setTimeout(() => {
      startComicAnimation();
    }, config.transition.greyOutDelay);
  }, config.transition.initialDelay);
}

// Add keyboard event listener
document.addEventListener('keydown', handleKeyboardControls);

// Update the overlay click handler to use the startAnimation function
document.getElementById('overlay').onclick = startAnimation;

// Add handler for exiting fullscreen
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
document.addEventListener('mozfullscreenchange', handleFullscreenChange);
document.addEventListener('MSFullscreenChange', handleFullscreenChange);

function handleFullscreenChange() {
  if (!document.fullscreenElement && 
      !document.webkitFullscreenElement && 
      !document.mozFullScreenElement && 
      !document.msFullscreenElement) {
    // Reset the animation if user exits fullscreen
    // (Uncomment if you want to restart the animation when exiting fullscreen)
    // location.reload();
  }
}

window.onresize = calculatePositions;

// Initialize the application
applyConfig();
setupImages();
</script>

</body>
</html>